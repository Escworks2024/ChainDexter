<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Token Inflow Analyzer</title>
</head>
<body>
  <h1>Token Inflow Analyzer</h1>
  <p>Inserisci l'indirizzo del token e clicca "Analizza".</p>
  <input type="text" id="tokenAddress" placeholder="Token Address" />
  <button onclick="getTokenInflow()">Analizza</button>
  <pre id="output"></pre>

  <!-- Importa ethers.js versione 5.7.2 -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"></script>
  <script>
    // Configura il provider Infura con la tua API key
    const provider = new ethers.providers.JsonRpcProvider(
      "https://mainnet.infura.io/v3/26f37d1491f84a288a2f917ce277e3dc"
    );

    async function getTokenInflow() {
      // Prendi l'indirizzo del token dall'input
      const tokenAddress = document.getElementById("tokenAddress").value;
      const output = document.getElementById("output");

      // Controlla che l'indirizzo sia valido
      if (!ethers.utils.isAddress(tokenAddress)) {
        output.textContent = "Errore: Indirizzo non valido.";
        return;
      }

      // Calcola il timestamp di una settimana fa
      const oneWeekAgo = Math.floor(Date.now() / 1000) - 7 * 24 * 60 * 60;

      try {
        // Recupera il numero dell'ultimo blocco
        const latestBlock = await provider.getBlockNumber();

        // Recupera i log filtrati dagli ultimi 50000 blocchi (~7 giorni)
        const logs = await provider.getLogs({
          address: tokenAddress,
          fromBlock: latestBlock - 50000, // Approx 7 giorni
          toBlock: "latest"
        });

        let inflow = 0;
        let transactions = 0;

        // Analizza ogni log
        for (let log of logs) {
          const block = await provider.getBlock(log.blockNumber);

          // Filtra solo quelli negli ultimi 7 giorni
          if (block.timestamp >= oneWeekAgo) {
            const tx = await provider.getTransaction(log.transactionHash);

            // Gestisce la firma evitando errori di yParity
            const parsedTx = await provider.getTransaction(log.transactionHash, {
              disableStrictSignatureChecks: true
            });

            // Verifica che sia un inflow verso il token
            if (parsedTx.to && parsedTx.to.toLowerCase() === tokenAddress.toLowerCase()) {
              inflow += parseFloat(ethers.utils.formatUnits(parsedTx.value, 18));
              transactions++;
            }
          }
        }

        // Mostra il risultato
        output.textContent = `Totale inflow: ${inflow.toFixed(4)} tokens\nTransazioni: ${transactions}`;
      } catch (error) {
        output.textContent = `Errore: ${error.message}`;
      }
    }
  </script>
</body>
</html>


